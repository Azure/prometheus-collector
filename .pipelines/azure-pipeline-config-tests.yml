# trigger:
#   branches:
#     include:
#     - rashmi/config-tests
# schedule to run everyday
schedules:
- cron: '0 6 * * *'
  displayName: Daily config processing test run
  branches:
    include:
    - main

variables:
  HELM_CHART_NAME: 'prometheus-collector'
  ACR_REGISTRY: 'containerinsightsprod.azurecr.io'
  ACR_REPOSITORY: '/public/azuremonitor/containerinsights/cidev/prometheus-collector/images'
  ACR_REPOSITORY_HELM: '/public/azuremonitor/containerinsights/cidev'
  MCR_REGISTRY: 'mcr.microsoft.com'
  MCR_REPOSITORY: '/azuremonitor/containerinsights/cidev/prometheus-collector/images'
  MCR_REPOSITORY_HELM: '/azuremonitor/containerinsights/cidev/prometheus-collector'
  MCR_REPOSITORY_HELM_DEPENDENCIES: '/azuremonitor/containerinsights/cidev'
  BUILD_WINDOWS: true
  Codeql.Enabled: true
  GOLANG_VERSION: '1.23.7'
  TESTKUBE_GOLANG_VERSION: '1.23.2'
  FLUENT_BIT_VERSION: '3.2.2'

stages:
- stage: Deploy
  jobs:
  - deployment: Testkube
    displayName: "Test: AKS testkube tests"
    environment: Prometheus-Collector-Tests
    timeoutInMinutes: 360
    pool:
      name: Azure-Pipelines-CI-Test-EO
    condition: succeeded()
    variables:
      skipComponentGovernanceDetection: true
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
            persistCredentials: true

          - bash: |
              wget -qO - https://repo.testkube.io/key.pub | sudo apt-key add -
              echo "deb https://repo.testkube.io/linux linux main" | sudo tee -a /etc/apt/sources.list
              sudo apt-get update
              sudo apt-get install -y testkube

              exit 0
            workingDirectory: $(Build.SourcesDirectory)
            displayName: "Install testkube CLI"

          - task: GoTool@0
            displayName: "Build: specify golang version"
            inputs:
              version: '1.22.7'

          - task: AzureCLI@1
            displayName: Get kubeconfig
            inputs:
              azureSubscription: 'ContainerInsights_Build_Subscription(9b96ebbd-c57a-42d1-bbe9-b69296e4c7fb)'
              scriptLocation: 'inlineScript'
              inlineScript: 'az aks get-credentials -g ci-dev-aks-tests -n ci-dev-aks-tests'
          
          - bash: |
              export AMW_QUERY_ENDPOINT="https://ci-dev-aks-tests-amw-fcdqc5d4agbyh9en.centralus.prometheus.monitor.azure.com"
              export AZURE_CLIENT_ID="f8b1889c-310c-4913-93c5-3faf0f594f34"

              envsubst < ./testkube/config-processing-test-crs/testkube-config-test-no-configmaps-crs.yaml > ./testkube/testkube-config-test-no-configmaps-crs-ci-dev-aks-tests.yaml
              kubectl apply -f ./testkube/api-server-permissions.yaml
              kubectl apply -f ./testkube/testkube-config-test-no-configmaps-crs-ci-dev-aks-tests.yaml
              # Delete all the configmaps to test the no configmaps case
              kubectl delete -f ./test-cluster-yamls/configmaps/ama-metrics-settings-configmap.yaml
              kubectl delete -f ./test-cluster-yamls/configmaps/ama-metrics-prometheus-config-configmap.yaml
              kubectl delete -f ./test-cluster-yamls/configmaps/ama-metrics-prometheus-config-node-configmap.yaml
              kubectl delete -f ./test-cluster-yamls/configmaps/ama-metrics-prometheus-config-node-windows-configmap.yaml
              exit 0
            workingDirectory: $(Build.SourcesDirectory)/otelcollector/test/
            displayName: "Apply TestKube CRs for no configmaps"

          - bash: |
              sleep 360

              exit 0
            displayName: "Wait for config to get picked up"

          - bash: |
              # Run the full test suite
              kubectl testkube run testsuite config-tests-no-configmaps --verbose

              # Get the current id of the test suite now running
              execution_id=$(kubectl testkube get testsuiteexecutions --test-suite config-tests-no-configmaps --limit 1 | grep config-tests-no-configmaps | awk '{print $1}')

              # Watch until the all the tests in the test suite finish
              kubectl testkube watch testsuiteexecution $execution_id

              # Get the results as a formatted json file
              kubectl testkube get testsuiteexecution $execution_id --output json > testkube-results.json

              # For any test that has failed, print out the Ginkgo logs
              if [[ $(jq -r '.status' testkube-results.json) == "failed" ]]; then

                # Get each test name and id that failed
                jq -r '.executeStepResults[].execute[] | select(.execution.executionResult.status=="failed") | "\(.execution.testName) \(.execution.id)"' testkube-results.json | while read line; do
                  testName=$(echo $line | cut -d ' ' -f 1)
                  id=$(echo $line | cut -d ' ' -f 2)
                  echo "Test $testName failed. Test ID: $id"

                  # Get the Ginkgo logs of the test
                  kubectl testkube get execution $id > out 2>error.log

                  # Remove superfluous logs of everything before the last occurence of 'go downloading'.
                  # The actual errors can be viewed from the ADO run, instead of needing to view the testkube dashboard.
                  cat error.log | tac | awk '/go: downloading/ {exit} 1' | tac
                done

                # Explicitly fail the ADO task since at least one test failed
                exit 1
              fi

              exit 0
            workingDirectory: $(Build.SourcesDirectory)
            displayName: "Run tests for no configmaps"

          - bash: |
              export AMW_QUERY_ENDPOINT="https://ci-dev-aks-tests-amw-fcdqc5d4agbyh9en.centralus.prometheus.monitor.azure.com"
              export AZURE_CLIENT_ID="f8b1889c-310c-4913-93c5-3faf0f594f34"

              envsubst < ./testkube/config-processing-test-crs/testkube-config-test-all-targets-disabled-crs.yaml > ./testkube/testkube-config-test-all-targets-disabled-crs-ci-dev-aks-tests.yaml
              kubectl apply -f ./testkube/testkube-config-test-all-targets-disabled-crs-ci-dev-aks-tests.yaml
              kubectl apply -f ./test-cluster-yamls/configmaps/default-config-map/ama-metrics-settings-configmap-all-targets-disabled.yaml

              exit 0
            workingDirectory: $(Build.SourcesDirectory)/otelcollector/test/
            displayName: "Apply TestKube CRs, scrape configs for all targets disabled"

          - bash: |
              sleep 360

              exit 0
            displayName: "Wait for cluster to be ready"

          - bash: |
              # Run the full test suite
              kubectl testkube run testsuite config-tests-all-targets-disabled --verbose

              # Get the current id of the test suite now running
              execution_id=$(kubectl testkube get testsuiteexecutions --test-suite config-tests-all-targets-disabled --limit 1 | grep config-tests-all-targets-disabled | awk '{print $1}')

              # Watch until the all the tests in the test suite finish
              kubectl testkube watch testsuiteexecution $execution_id

              # Get the results as a formatted json file
              kubectl testkube get testsuiteexecution $execution_id --output json > testkube-results.json

              # For any test that has failed, print out the Ginkgo logs
              if [[ $(jq -r '.status' testkube-results.json) == "failed" ]]; then

                # Get each test name and id that failed
                jq -r '.executeStepResults[].execute[] | select(.execution.executionResult.status=="failed") | "\(.execution.testName) \(.execution.id)"' testkube-results.json | while read line; do
                  testName=$(echo $line | cut -d ' ' -f 1)
                  id=$(echo $line | cut -d ' ' -f 2)
                  echo "Test $testName failed. Test ID: $id"

                  # Get the Ginkgo logs of the test
                  kubectl testkube get execution $id > out 2>error.log

                  # Remove superfluous logs of everything before the last occurence of 'go downloading'.
                  # The actual errors can be viewed from the ADO run, instead of needing to view the testkube dashboard.
                  cat error.log | tac | awk '/go: downloading/ {exit} 1' | tac
                done

                # Explicitly fail the ADO task since at least one test failed
                exit 1
              fi

              exit 0
            workingDirectory: $(Build.SourcesDirectory)
            displayName: "Run tests for all targets disabled"

          - bash: |
              export AMW_QUERY_ENDPOINT="https://ci-dev-aks-tests-amw-fcdqc5d4agbyh9en.centralus.prometheus.monitor.azure.com"
              export AZURE_CLIENT_ID="f8b1889c-310c-4913-93c5-3faf0f594f34"

              envsubst < ./testkube/config-processing-test-crs/testkube-config-test-default-targets-on-crs.yaml > ./testkube/testkube-config-test-default-targets-on-crs-ci-dev-aks-tests.yaml
              kubectl apply -f ./testkube/testkube-config-test-default-targets-on-crs-ci-dev-aks-tests.yaml
              kubectl apply -f ./test-cluster-yamls/configmaps/default-config-map/ama-metrics-settings-configmap-defaults-targets-turned-on.yaml

              exit 0
            workingDirectory: $(Build.SourcesDirectory)/otelcollector/test/
            displayName: "Apply TestKube CRs, scrape configs for all default targets in setting configmap enabled"

          - bash: |
              sleep 360

              exit 0
            displayName: "Wait for cluster to be ready"

          - bash: |
              # Run the full test suite
              kubectl testkube run testsuite config-tests-def-targets-on-configmap --verbose

              # Get the current id of the test suite now running
              execution_id=$(kubectl testkube get testsuiteexecutions --test-suite config-tests-def-targets-on-configmap --limit 1 | grep config-tests-def-targets-on-configmap | awk '{print $1}')

              # Watch until the all the tests in the test suite finish
              kubectl testkube watch testsuiteexecution $execution_id

              # Get the results as a formatted json file
              kubectl testkube get testsuiteexecution $execution_id --output json > testkube-results.json

              # For any test that has failed, print out the Ginkgo logs
              if [[ $(jq -r '.status' testkube-results.json) == "failed" ]]; then

                # Get each test name and id that failed
                jq -r '.executeStepResults[].execute[] | select(.execution.executionResult.status=="failed") | "\(.execution.testName) \(.execution.id)"' testkube-results.json | while read line; do
                  testName=$(echo $line | cut -d ' ' -f 1)
                  id=$(echo $line | cut -d ' ' -f 2)
                  echo "Test $testName failed. Test ID: $id"

                  # Get the Ginkgo logs of the test
                  kubectl testkube get execution $id > out 2>error.log

                  # Remove superfluous logs of everything before the last occurence of 'go downloading'.
                  # The actual errors can be viewed from the ADO run, instead of needing to view the testkube dashboard.
                  cat error.log | tac | awk '/go: downloading/ {exit} 1' | tac
                done

                # Explicitly fail the ADO task since at least one test failed
                exit 1
              fi

              exit 0
            workingDirectory: $(Build.SourcesDirectory)
            displayName: "Run tests for all default targets in settings cfg map enabled"

          - bash: |
              export AMW_QUERY_ENDPOINT="https://ci-dev-aks-tests-amw-fcdqc5d4agbyh9en.centralus.prometheus.monitor.azure.com"
              export AZURE_CLIENT_ID="f8b1889c-310c-4913-93c5-3faf0f594f34"

              envsubst < ./testkube/config-processing-test-crs/testkube-config-test-all-rs-targets-enabled-crs.yaml > ./testkube/testkube-config-test-all-rs-targets-enabled-crs-ci-dev-aks-tests.yaml
              kubectl apply -f ./testkube/testkube-config-test-all-rs-targets-enabled-crs-ci-dev-aks-tests.yaml
              kubectl apply -f ./test-cluster-yamls/configmaps/default-config-map/ama-metrics-settings-configmap-rs-targets-enabled.yaml

              exit 0
            workingDirectory: $(Build.SourcesDirectory)/otelcollector/test/
            displayName: "Apply TestKube CRs, scrape configs for all rs targets in setting configmap enabled"

          - bash: |
              sleep 360

              exit 0
            displayName: "Wait for cluster to be ready"

          - bash: |
              # Run the full test suite
              kubectl testkube run testsuite config-tests-all-rs-targets-enabled --verbose

              # Get the current id of the test suite now running
              execution_id=$(kubectl testkube get testsuiteexecutions --test-suite config-tests-all-rs-targets-enabled --limit 1 | grep config-tests-all-rs-targets-enabled | awk '{print $1}')

              # Watch until the all the tests in the test suite finish
              kubectl testkube watch testsuiteexecution $execution_id

              # Get the results as a formatted json file
              kubectl testkube get testsuiteexecution $execution_id --output json > testkube-results.json

              # For any test that has failed, print out the Ginkgo logs
              if [[ $(jq -r '.status' testkube-results.json) == "failed" ]]; then

                # Get each test name and id that failed
                jq -r '.executeStepResults[].execute[] | select(.execution.executionResult.status=="failed") | "\(.execution.testName) \(.execution.id)"' testkube-results.json | while read line; do
                  testName=$(echo $line | cut -d ' ' -f 1)
                  id=$(echo $line | cut -d ' ' -f 2)
                  echo "Test $testName failed. Test ID: $id"

                  # Get the Ginkgo logs of the test
                  kubectl testkube get execution $id > out 2>error.log

                  # Remove superfluous logs of everything before the last occurence of 'go downloading'.
                  # The actual errors can be viewed from the ADO run, instead of needing to view the testkube dashboard.
                  cat error.log | tac | awk '/go: downloading/ {exit} 1' | tac
                done

                # Explicitly fail the ADO task since at least one test failed
                exit 1
              fi

              exit 0
            workingDirectory: $(Build.SourcesDirectory)
            displayName: "Run tests for all rs targets in settings cfg map enabled"

          - bash: |
              export AMW_QUERY_ENDPOINT="https://ci-dev-aks-tests-amw-fcdqc5d4agbyh9en.centralus.prometheus.monitor.azure.com"
              export AZURE_CLIENT_ID="f8b1889c-310c-4913-93c5-3faf0f594f34"

              envsubst < ./testkube/config-processing-test-crs/testkube-config-test-all-ds-targets-enabled-crs.yaml > ./testkube/testkube-config-test-all-ds-targets-enabled-crs-ci-dev-aks-tests.yaml
              kubectl apply -f ./testkube/testkube-config-test-all-ds-targets-enabled-crs-ci-dev-aks-tests.yaml
              kubectl apply -f ./test-cluster-yamls/configmaps/default-config-map/ama-metrics-settings-configmap-ds-targets-enabled.yaml

              exit 0
            workingDirectory: $(Build.SourcesDirectory)/otelcollector/test/
            displayName: "Apply TestKube CRs, scrape configs for all ds targets in setting configmap enabled"

          - bash: |
              sleep 360

              exit 0
            displayName: "Wait for cluster to be ready"

          - bash: |
              # Run the full test suite
              kubectl testkube run testsuite config-tests-all-ds-targets-enabled --verbose

              # Get the current id of the test suite now running
              execution_id=$(kubectl testkube get testsuiteexecutions --test-suite config-tests-all-ds-targets-enabled --limit 1 | grep config-tests-all-ds-targets-enabled | awk '{print $1}')

              # Watch until the all the tests in the test suite finish
              kubectl testkube watch testsuiteexecution $execution_id

              # Get the results as a formatted json file
              kubectl testkube get testsuiteexecution $execution_id --output json > testkube-results.json

              # For any test that has failed, print out the Ginkgo logs
              if [[ $(jq -r '.status' testkube-results.json) == "failed" ]]; then

                # Get each test name and id that failed
                jq -r '.executeStepResults[].execute[] | select(.execution.executionResult.status=="failed") | "\(.execution.testName) \(.execution.id)"' testkube-results.json | while read line; do
                  testName=$(echo $line | cut -d ' ' -f 1)
                  id=$(echo $line | cut -d ' ' -f 2)
                  echo "Test $testName failed. Test ID: $id"

                  # Get the Ginkgo logs of the test
                  kubectl testkube get execution $id > out 2>error.log

                  # Remove superfluous logs of everything before the last occurence of 'go downloading'.
                  # The actual errors can be viewed from the ADO run, instead of needing to view the testkube dashboard.
                  cat error.log | tac | awk '/go: downloading/ {exit} 1' | tac
                done

                # Explicitly fail the ADO task since at least one test failed
                exit 1
              fi

              exit 0
            workingDirectory: $(Build.SourcesDirectory)
            displayName: "Run tests for all ds targets in settings cfg map enabled"

          - bash: |
              export AMW_QUERY_ENDPOINT="https://ci-dev-aks-tests-amw-fcdqc5d4agbyh9en.centralus.prometheus.monitor.azure.com"
              export AZURE_CLIENT_ID="f8b1889c-310c-4913-93c5-3faf0f594f34"

              envsubst < ./testkube/config-processing-test-crs/testkube-config-test-all-targets-enabled-crs.yaml > ./testkube/testkube-config-test-all-targets-enabled-crs-ci-dev-aks-tests.yaml
              kubectl apply -f ./testkube/testkube-config-test-all-targets-enabled-crs-ci-dev-aks-tests.yaml
              kubectl apply -f ./test-cluster-yamls/configmaps/default-config-map/ama-metrics-settings-configmap-all-targets-enabled.yaml

              exit 0
            workingDirectory: $(Build.SourcesDirectory)/otelcollector/test/
            displayName: "Apply TestKube CRs, scrape configs for all targets in setting configmap enabled"

          - bash: |
              sleep 360

              exit 0
            displayName: "Wait for cluster to be ready"

          - bash: |
              # Run the full test suite
              kubectl testkube run testsuite config-tests-all-targets-enabled --verbose

              # Get the current id of the test suite now running
              execution_id=$(kubectl testkube get testsuiteexecutions --test-suite config-tests-all-targets-enabled --limit 1 | grep config-tests-all-targets-enabled | awk '{print $1}')

              # Watch until the all the tests in the test suite finish
              kubectl testkube watch testsuiteexecution $execution_id

              # Get the results as a formatted json file
              kubectl testkube get testsuiteexecution $execution_id --output json > testkube-results.json

              # For any test that has failed, print out the Ginkgo logs
              if [[ $(jq -r '.status' testkube-results.json) == "failed" ]]; then

                # Get each test name and id that failed
                jq -r '.executeStepResults[].execute[] | select(.execution.executionResult.status=="failed") | "\(.execution.testName) \(.execution.id)"' testkube-results.json | while read line; do
                  testName=$(echo $line | cut -d ' ' -f 1)
                  id=$(echo $line | cut -d ' ' -f 2)
                  echo "Test $testName failed. Test ID: $id"

                  # Get the Ginkgo logs of the test
                  kubectl testkube get execution $id > out 2>error.log

                  # Remove superfluous logs of everything before the last occurence of 'go downloading'.
                  # The actual errors can be viewed from the ADO run, instead of needing to view the testkube dashboard.
                  cat error.log | tac | awk '/go: downloading/ {exit} 1' | tac
                done

                # Explicitly fail the ADO task since at least one test failed
                exit 1
              fi

              exit 0
            workingDirectory: $(Build.SourcesDirectory)
            displayName: "Run tests for all targets in settings cfg map enabled"

          - bash: |
              export AMW_QUERY_ENDPOINT="https://ci-dev-aks-tests-amw-fcdqc5d4agbyh9en.centralus.prometheus.monitor.azure.com"
              export AZURE_CLIENT_ID="f8b1889c-310c-4913-93c5-3faf0f594f34"

              envsubst < ./testkube/config-processing-test-crs/testkube-config-test-only-custom-configmap-crs.yaml > ./testkube/testkube-config-test-only-custom-configmap-crs-ci-dev-aks-tests.yaml
              kubectl apply -f ./testkube/testkube-config-test-only-custom-configmap-crs-ci-dev-aks-tests.yaml
              kubectl delete -f ./test-cluster-yamls/configmaps/ama-metrics-settings-configmap.yaml
              kubectl delete -f ./test-cluster-yamls/configmaps/ama-metrics-prometheus-config-node-configmap.yaml
              kubectl delete -f ./test-cluster-yamls/configmaps/ama-metrics-prometheus-config-node-windows-configmap.yaml
              kubectl apply -f ./test-cluster-yamls/configmaps/default-config-map/ama-metrics-settings-configmap-defaults-targets-turned-on.yaml
              kubectl apply -f ./test-cluster-yamls/configmaps/custom-config-map/ama-metrics-prometheus-config-configmap-all-actions.yaml

              exit 0
            workingDirectory: $(Build.SourcesDirectory)/otelcollector/test/
            displayName: "Apply TestKube CRs, scrape configs for custom configmap with all actions enabled"

          - bash: |
              sleep 360

              exit 0
            displayName: "Wait for cluster to be ready"

          - bash: |
              # Run the full test suite
              kubectl testkube run testsuite config-tests-custom-configmap-all-actions --verbose

              # Get the current id of the test suite now running
              execution_id=$(kubectl testkube get testsuiteexecutions --test-suite config-tests-custom-configmap-all-actions --limit 1 | grep config-tests-custom-configmap-all-actions | awk '{print $1}')

              # Watch until the all the tests in the test suite finish
              kubectl testkube watch testsuiteexecution $execution_id

              # Get the results as a formatted json file
              kubectl testkube get testsuiteexecution $execution_id --output json > testkube-results.json

              # For any test that has failed, print out the Ginkgo logs
              if [[ $(jq -r '.status' testkube-results.json) == "failed" ]]; then

                # Get each test name and id that failed
                jq -r '.executeStepResults[].execute[] | select(.execution.executionResult.status=="failed") | "\(.execution.testName) \(.execution.id)"' testkube-results.json | while read line; do
                  testName=$(echo $line | cut -d ' ' -f 1)
                  id=$(echo $line | cut -d ' ' -f 2)
                  echo "Test $testName failed. Test ID: $id"

                  # Get the Ginkgo logs of the test
                  kubectl testkube get execution $id > out 2>error.log

                  # Remove superfluous logs of everything before the last occurence of 'go downloading'.
                  # The actual errors can be viewed from the ADO run, instead of needing to view the testkube dashboard.
                  cat error.log | tac | awk '/go: downloading/ {exit} 1' | tac
                done

                # Explicitly fail the ADO task since at least one test failed
                exit 1
              fi

              exit 0
            workingDirectory: $(Build.SourcesDirectory)
            displayName: "Run tests for custom configmap with all actions enabled"

          - bash: |
              export AMW_QUERY_ENDPOINT="https://ci-dev-aks-tests-amw-fcdqc5d4agbyh9en.centralus.prometheus.monitor.azure.com"
              export AZURE_CLIENT_ID="f8b1889c-310c-4913-93c5-3faf0f594f34"

              envsubst < ./testkube/config-processing-test-crs/testkube-config-test-global-settings-crs.yaml > ./testkube/testkube-config-test-global-settings-crs-ci-dev-aks-tests.yaml
              kubectl apply -f ./testkube/testkube-config-test-global-settings-crs-ci-dev-aks-tests.yaml
              kubectl apply -f ./test-cluster-yamls/configmaps/ama-metrics-prometheus-config-configmap.yaml

              exit 0
            workingDirectory: $(Build.SourcesDirectory)/otelcollector/test/
            displayName: "Apply TestKube CRs, scrape configs for global ext labels enabled"

          - bash: |
              sleep 360

              exit 0
            displayName: "Wait for cluster to be ready"

          - bash: |
              # Run the full test suite
              kubectl testkube run testsuite config-tests-global-ext-labels --verbose

              # Get the current id of the test suite now running
              execution_id=$(kubectl testkube get testsuiteexecutions --test-suite config-tests-global-ext-labels --limit 1 | grep config-tests-global-ext-labels | awk '{print $1}')

              # Watch until the all the tests in the test suite finish
              kubectl testkube watch testsuiteexecution $execution_id

              # Get the results as a formatted json file
              kubectl testkube get testsuiteexecution $execution_id --output json > testkube-results.json

              # For any test that has failed, print out the Ginkgo logs
              if [[ $(jq -r '.status' testkube-results.json) == "failed" ]]; then

                # Get each test name and id that failed
                jq -r '.executeStepResults[].execute[] | select(.execution.executionResult.status=="failed") | "\(.execution.testName) \(.execution.id)"' testkube-results.json | while read line; do
                  testName=$(echo $line | cut -d ' ' -f 1)
                  id=$(echo $line | cut -d ' ' -f 2)
                  echo "Test $testName failed. Test ID: $id"

                  # Get the Ginkgo logs of the test
                  kubectl testkube get execution $id > out 2>error.log

                  # Remove superfluous logs of everything before the last occurence of 'go downloading'.
                  # The actual errors can be viewed from the ADO run, instead of needing to view the testkube dashboard.
                  cat error.log | tac | awk '/go: downloading/ {exit} 1' | tac
                done

                # Explicitly fail the ADO task since at least one test failed
                exit 1
              fi

              exit 0
            workingDirectory: $(Build.SourcesDirectory)
            displayName: "Run tests for global ext labels enabled"

          - bash: |
              export AMW_QUERY_ENDPOINT="https://ci-dev-aks-tests-amw-fcdqc5d4agbyh9en.centralus.prometheus.monitor.azure.com"
              export AZURE_CLIENT_ID="f8b1889c-310c-4913-93c5-3faf0f594f34"

              envsubst < ./testkube/config-processing-test-crs/testkube-config-test-custom-node-configmap-crs.yaml > ./testkube/testkube-config-test-custom-node-configmap-crs-ci-dev-aks-tests.yaml
              kubectl apply -f ./testkube/testkube-config-test-custom-node-configmap-crs-ci-dev-aks-tests.yaml
              kubectl apply -f ./test-cluster-yamls/configmaps/custom-config-map/ama-metrics-prometheus-config-configmap-all-actions.yaml
              kubectl apply -f ./test-cluster-yamls/configmaps/ama-metrics-prometheus-config-node-configmap.yaml
              kubectl apply -f ./test-cluster-yamls/configmaps/ama-metrics-prometheus-config-node-windows-configmap.yaml
              exit 0
            workingDirectory: $(Build.SourcesDirectory)/otelcollector/test/
            displayName: "Apply TestKube CRs, scrape configs for custom node configmap enabled"

          - bash: |
              sleep 360

              exit 0
            displayName: "Wait for cluster to be ready"

          - bash: |
              # Run the full test suite
              kubectl testkube run testsuite config-tests-node-configmaps --verbose

              # Get the current id of the test suite now running
              execution_id=$(kubectl testkube get testsuiteexecutions --test-suite config-tests-node-configmaps --limit 1 | grep config-tests-node-configmaps | awk '{print $1}')

              # Watch until the all the tests in the test suite finish
              kubectl testkube watch testsuiteexecution $execution_id

              # Get the results as a formatted json file
              kubectl testkube get testsuiteexecution $execution_id --output json > testkube-results.json

              # For any test that has failed, print out the Ginkgo logs
              if [[ $(jq -r '.status' testkube-results.json) == "failed" ]]; then

                # Get each test name and id that failed
                jq -r '.executeStepResults[].execute[] | select(.execution.executionResult.status=="failed") | "\(.execution.testName) \(.execution.id)"' testkube-results.json | while read line; do
                  testName=$(echo $line | cut -d ' ' -f 1)
                  id=$(echo $line | cut -d ' ' -f 2)
                  echo "Test $testName failed. Test ID: $id"

                  # Get the Ginkgo logs of the test
                  kubectl testkube get execution $id > out 2>error.log

                  # Remove superfluous logs of everything before the last occurence of 'go downloading'.
                  # The actual errors can be viewed from the ADO run, instead of needing to view the testkube dashboard.
                  cat error.log | tac | awk '/go: downloading/ {exit} 1' | tac
                done

                # Explicitly fail the ADO task since at least one test failed
                exit 1
              fi

              exit 0
            workingDirectory: $(Build.SourcesDirectory)
            displayName: "Run tests for custom node configmap enabled"

          - bash: |
              export AMW_QUERY_ENDPOINT="https://ci-dev-aks-tests-amw-fcdqc5d4agbyh9en.centralus.prometheus.monitor.azure.com"
              export AZURE_CLIENT_ID="f8b1889c-310c-4913-93c5-3faf0f594f34"

              envsubst < ./testkube/config-processing-test-crs/testkube-config-test-settings-error-crs.yaml > ./testkube/testkube-config-test-settings-error-crs-ci-dev-aks-tests.yaml
              kubectl apply -f ./testkube/testkube-config-test-settings-error-crs-ci-dev-aks-tests.yaml
              kubectl delete -f ./test-cluster-yamls/configmaps/ama-metrics-prometheus-config-configmap.yaml
              kubectl delete -f ./test-cluster-yamls/configmaps/ama-metrics-prometheus-config-node-configmap.yaml
              kubectl delete -f ./test-cluster-yamls/configmaps/ama-metrics-prometheus-config-node-windows-configmap.yaml
              kubectl apply -f ./test-cluster-yamls/configmaps/default-config-map/ama-metrics-settings-configmap-error.yaml

              exit 0
            workingDirectory: $(Build.SourcesDirectory)/otelcollector/test/
            displayName: "Apply TestKube CRs, scrape configs for errorprone settings configmap"

          - bash: |
              sleep 360

              exit 0
            displayName: "Wait for cluster to be ready"

          - bash: |
              # Run the full test suite
              kubectl testkube run testsuite config-tests-error-settings-configmap --verbose

              # Get the current id of the test suite now running
              execution_id=$(kubectl testkube get testsuiteexecutions --test-suite config-tests-error-settings-configmap --limit 1 | grep config-tests-error-settings-configmap | awk '{print $1}')

              # Watch until the all the tests in the test suite finish
              kubectl testkube watch testsuiteexecution $execution_id

              # Get the results as a formatted json file
              kubectl testkube get testsuiteexecution $execution_id --output json > testkube-results.json

              # For any test that has failed, print out the Ginkgo logs
              if [[ $(jq -r '.status' testkube-results.json) == "failed" ]]; then

                # Get each test name and id that failed
                jq -r '.executeStepResults[].execute[] | select(.execution.executionResult.status=="failed") | "\(.execution.testName) \(.execution.id)"' testkube-results.json | while read line; do
                  testName=$(echo $line | cut -d ' ' -f 1)
                  id=$(echo $line | cut -d ' ' -f 2)
                  echo "Test $testName failed. Test ID: $id"

                  # Get the Ginkgo logs of the test
                  kubectl testkube get execution $id > out 2>error.log

                  # Remove superfluous logs of everything before the last occurence of 'go downloading'.
                  # The actual errors can be viewed from the ADO run, instead of needing to view the testkube dashboard.
                  cat error.log | tac | awk '/go: downloading/ {exit} 1' | tac
                done

                # Explicitly fail the ADO task since at least one test failed
                exit 1
              fi

              exit 0
            workingDirectory: $(Build.SourcesDirectory)
            displayName: "Run tests for errorprone settings configmap"

          - bash: |
              export AMW_QUERY_ENDPOINT="https://ci-dev-aks-tests-amw-fcdqc5d4agbyh9en.centralus.prometheus.monitor.azure.com"
              export AZURE_CLIENT_ID="f8b1889c-310c-4913-93c5-3faf0f594f34"

              envsubst < ./testkube/config-processing-test-crs/testkube-config-test-custom-configmap-error-crs.yaml > ./testkube/testkube-config-test-custom-configmap-error-crs-ci-dev-aks-tests.yaml
              kubectl apply -f ./testkube/testkube-config-test-custom-configmap-error-crs-ci-dev-aks-tests.yaml
              kubectl apply -f ./test-cluster-yamls/configmaps/default-config-map/ama-metrics-settings-configmap-defaults-targets-turned-on.yaml
              kubectl apply -f ./test-cluster-yamls/configmaps/custom-config-map/ama-metrics-prometheus-config-configmap-with-error.yaml
              kubectl apply -f ./test-cluster-yamls/configmaps/custom-config-map-node/ama-metrics-prometheus-config-node-configmap-errors.yaml
              kubectl apply -f ./test-cluster-yamls/configmaps/custom-config-map-win/ama-metrics-prometheus-config-node-windows-configmap-errors.yaml
              exit 0
            workingDirectory: $(Build.SourcesDirectory)/otelcollector/test/
            displayName: "Apply TestKube CRs, scrape configs for errorprone custom configmap"

          - bash: |
              sleep 360

              exit 0
            displayName: "Wait for cluster to be ready"

          - bash: |
              # Run the full test suite
              kubectl testkube run testsuite config-tests-custom-configmap-error --verbose

              # Get the current id of the test suite now running
              execution_id=$(kubectl testkube get testsuiteexecutions --test-suite config-tests-custom-configmap-error --limit 1 | grep config-tests-custom-configmap-error | awk '{print $1}')

              # Watch until the all the tests in the test suite finish
              kubectl testkube watch testsuiteexecution $execution_id

              # Get the results as a formatted json file
              kubectl testkube get testsuiteexecution $execution_id --output json > testkube-results.json

              # For any test that has failed, print out the Ginkgo logs
              if [[ $(jq -r '.status' testkube-results.json) == "failed" ]]; then

                # Get each test name and id that failed
                jq -r '.executeStepResults[].execute[] | select(.execution.executionResult.status=="failed") | "\(.execution.testName) \(.execution.id)"' testkube-results.json | while read line; do
                  testName=$(echo $line | cut -d ' ' -f 1)
                  id=$(echo $line | cut -d ' ' -f 2)
                  echo "Test $testName failed. Test ID: $id"

                  # Get the Ginkgo logs of the test
                  kubectl testkube get execution $id > out 2>error.log

                  # Remove superfluous logs of everything before the last occurence of 'go downloading'.
                  # The actual errors can be viewed from the ADO run, instead of needing to view the testkube dashboard.
                  cat error.log | tac | awk '/go: downloading/ {exit} 1' | tac
                done

                # Explicitly fail the ADO task since at least one test failed
                exit 1
              fi

              exit 0
            workingDirectory: $(Build.SourcesDirectory)
            displayName: "Run tests for errorprone custom configmap"

          - bash: |
              export AMW_QUERY_ENDPOINT="https://ci-dev-aks-tests-amw-fcdqc5d4agbyh9en.centralus.prometheus.monitor.azure.com"
              export AZURE_CLIENT_ID="f8b1889c-310c-4913-93c5-3faf0f594f34"

              envsubst < ./testkube/config-processing-test-crs/testkube-config-test-global-ext-labels-error-crs.yaml > ./testkube/testkube-config-test-global-ext-labels-error-crs-ci-dev-aks-tests.yaml
              kubectl apply -f ./testkube/testkube-config-test-global-ext-labels-error-crs-ci-dev-aks-tests.yaml
              kubectl apply -f ./test-cluster-yamls/configmaps/default-config-map/ama-metrics-settings-configmap-defaults-targets-turned-on.yaml
              kubectl apply -f ./test-cluster-yamls/configmaps/global-settings/ama-metrics-prometheus-config-configmap-with-global-error.yaml

              exit 0
            workingDirectory: $(Build.SourcesDirectory)/otelcollector/test/
            displayName: "Apply TestKube CRs, scrape configs for errorprone global ext labels"

          - bash: |
              sleep 360

              exit 0
            displayName: "Wait for cluster to be ready"

          - bash: |
              # Run the full test suite
              kubectl testkube run testsuite config-global-ext-labels-error --verbose

              # Get the current id of the test suite now running
              execution_id=$(kubectl testkube get testsuiteexecutions --test-suite config-global-ext-labels-error --limit 1 | config-global-ext-labels-error | awk '{print $1}')

              # Watch until the all the tests in the test suite finish
              kubectl testkube watch testsuiteexecution $execution_id

              # Get the results as a formatted json file
              kubectl testkube get testsuiteexecution $execution_id --output json > testkube-results.json

              # For any test that has failed, print out the Ginkgo logs
              if [[ $(jq -r '.status' testkube-results.json) == "failed" ]]; then

                # Get each test name and id that failed
                jq -r '.executeStepResults[].execute[] | select(.execution.executionResult.status=="failed") | "\(.execution.testName) \(.execution.id)"' testkube-results.json | while read line; do
                  testName=$(echo $line | cut -d ' ' -f 1)
                  id=$(echo $line | cut -d ' ' -f 2)
                  echo "Test $testName failed. Test ID: $id"

                  # Get the Ginkgo logs of the test
                  kubectl testkube get execution $id > out 2>error.log

                  # Remove superfluous logs of everything before the last occurence of 'go downloading'.
                  # The actual errors can be viewed from the ADO run, instead of needing to view the testkube dashboard.
                  cat error.log | tac | awk '/go: downloading/ {exit} 1' | tac
                done

                # Explicitly fail the ADO task since at least one test failed
                exit 1
              fi

              exit 0
            workingDirectory: $(Build.SourcesDirectory)
            displayName: "Run tests for errorprone global ext labels"