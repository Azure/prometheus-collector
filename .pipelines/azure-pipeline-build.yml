trigger:
  branches:
    include:
    - main
    - bot/otelcollector-upgrade-*
    - dependabot*
pr:
  autoCancel: true
  branches:
    include:
    - main

parameters:
- name: featureFlags
  type: object
  default:
    LinuxHostVersion:
      Network: KS1
    WindowsHostVersion:
      Network: KS1

variables:
  HELM_CHART_NAME: 'prometheus-collector'
  ARC_HELM_CHART_NAME: 'ama-metrics-arc'
  ACR_REGISTRY: 'containerinsightsprod.azurecr.io'
  ACR_REPOSITORY: '/public/azuremonitor/containerinsights/cidev/prometheus-collector/images'
  ACR_REPOSITORY_HELM: '/public/azuremonitor/containerinsights/cidev'
  MCR_REGISTRY: 'mcr.microsoft.com'
  MCR_REPOSITORY: '/azuremonitor/containerinsights/cidev/prometheus-collector/images'
  MCR_REPOSITORY_HELM: '/azuremonitor/containerinsights/cidev/prometheus-collector'
  MCR_REPOSITORY_HELM_DEPENDENCIES: '/azuremonitor/containerinsights/cidev'
  KUBE_STATE_METRICS_IMAGE: 'mcr.microsoft.com/oss/v2/kubernetes/kube-state-metrics:v2.17.0-4'
  NODE_EXPORTER_IMAGE: 'mcr.microsoft.com/oss/v2/prometheus/node-exporter:v1.9.1'
  IS_PR: $[eq(variables['Build.Reason'], 'PullRequest')]
  IS_MAIN_BRANCH: $[eq(variables['Build.SourceBranchName'], 'main')]
  IS_OTEL_UPGRADE_BRANCH: $[startsWith(variables['Build.SourceBranchName'], 'otelcollector-upgrade-')]
  BUILD_WINDOWS: true
  Codeql.Enabled: true
  GOLANG_VERSION: '1.24.11'
  FLUENTBIT_GOLANG_VERSION: '1.24.6'
  TESTKUBE_GOLANG_VERSION: '1.23.10'
  FLUENT_BIT_VERSION: '3.2.2'
  PROMETHEUS_VERSION: '3.2.1'
  HELM_VERSION: '3.12.3'
resources:
  repositories:
  - repository: 1ESPipelineTemplates
    type: git
    name: 1ESPipelineTemplates/1ESPipelineTemplates
    ref: refs/tags/release
extends:
  template: v1/1ES.Official.PipelineTemplate.yml@1ESPipelineTemplates
  parameters:
    pool:
      name: Azure-Pipelines-CI-Test-EO
      image: ci-1es-managed-ubuntu-2204
      os: linux
    sdl:
      sourceAnalysisPool:
        name: Azure-Pipelines-CI-Test-EO
        image: ci-1es-managed-windows-2022
        os: windows
      componentgovernance: 
        ignoreDirectories: 'mixins,internal,tools'
    customBuildTags:
    - ES365AIMigrationTooling

    stages:
    - stage: Build
      jobs:
      - job: Image_Tags_and_Ev2_Artifacts
        displayName: "Build: Set image tags and publish Ev2 artifacts"
        pool:
          name: Azure-Pipelines-CI-Test-EO
          image: ci-1es-managed-ubuntu-2204
          os: linux
        variables:
          skipComponentGovernanceDetection: true
        templateContext:
          outputs:
          - output: pipelineArtifact
            displayName: 'Ev2: publish Ev2 deployment artifacts'
            targetPath: '$(Build.ArtifactStagingDirectory)'
            artifactName: ev2-drop
        steps:
        - checkout: self
          submodules: true
        - bash: |
            if [ $(IS_PR) == "True" ]; then
              BRANCH_NAME=$(System.PullRequest.SourceBranch)
            else
              BRANCH_NAME=$(Build.SourceBranch)
              BRANCH_NAME=${BRANCH_NAME#refs/heads/}
            fi
            BRANCH_NAME=$(echo $BRANCH_NAME | tr / - | tr . - | tr _ - | cut -c1-90)
            COMMIT_SHA=$(echo $(Build.SourceVersion) | cut -b -8)
            DATE=$(TZ=America/Los_Angeles date +%m-%d-%Y)
            VERSION=$(cat $(Build.SourcesDirectory)/otelcollector/VERSION)
            SEMVER=$VERSION-$BRANCH_NAME-$DATE-$COMMIT_SHA
            LINUX_IMAGE_TAG=$SEMVER
            # Truncating to 128 characters as it is required by docker
            LINUX_IMAGE_TAG=$(echo "${LINUX_IMAGE_TAG}" | cut -c1-128)
            #Truncating this to 128 to add the arm/amd suffix
            LINUX_MULTIARCH_TAG_PREFIX=$(echo "${LINUX_IMAGE_TAG}" | cut -c1-124)
            #Truncating this to 124 to add the cfg suffix
            LINUX_IMAGE_TAG_PREFIX=$(echo "${LINUX_IMAGE_TAG}" | cut -c1-124)
            LINUX_CONFIG_READER_IMAGE_TAG=$LINUX_IMAGE_TAG_PREFIX-cfg
            LINUX_CCP_IMAGE_TAG=$LINUX_IMAGE_TAG_PREFIX-ccp
            LINUX_CCP_IMAGE_TAG=$LINUX_IMAGE_TAG_PREFIX-ccp
            LINUX_ARM64_IMAGE_TAG=$LINUX_IMAGE_TAG_PREFIX-arm
            LINUX_AMD64_IMAGE_TAG=$LINUX_IMAGE_TAG_PREFIX-amd
            #Truncating this to 113 to add the ref app suffices
            LINUX_REF_APP_IMAGE_TAG_PREFIX=$(echo "${LINUX_IMAGE_TAG}" | cut -c1-113)
            LINUX_REF_APP_GOLANG_IMAGE_TAG=$LINUX_REF_APP_IMAGE_TAG_PREFIX-ref-app-golang
            LINUX_REF_APP_PYTHON_IMAGE_TAG=$LINUX_REF_APP_IMAGE_TAG_PREFIX-ref-app-python
            # Truncating to 115 characters as it is required by docker (4 characters used in -win, 9 characters used in -ltsc2019/-ltsc2022, 10 characters used in -unsigned)
            WINDOWS_IMAGE_TAG_PREFIX=$(echo "${LINUX_IMAGE_TAG}" | cut -c1-105)
            WINDOWS_IMAGE_TAG=$WINDOWS_IMAGE_TAG_PREFIX-win
            #Truncating this to 112 characters to add the targetallocator suffix
            TARGET_ALLOCATOR_IMAGE_TAG_PREFIX=$(echo "${LINUX_IMAGE_TAG}" | cut -c1-112)
            TARGET_ALLOCATOR_IMAGE_TAG=$TARGET_ALLOCATOR_IMAGE_TAG_PREFIX-targetallocator
            #Truncating this 108 to characters to add the targetallocator-arm/amd suffix
            TARGET_ALLOCATOR_MULTIARCH_TAG_PREFIX=$(echo "${LINUX_IMAGE_TAG}" | cut -c1-108)
            TARGET_ALLOCATOR_ARM64_IMAGE_TAG=$TARGET_ALLOCATOR_MULTIARCH_TAG_PREFIX-targetallocator-arm
            TARGET_ALLOCATOR_AMD64_IMAGE_TAG=$TARGET_ALLOCATOR_MULTIARCH_TAG_PREFIX-targetallocator-amd
            #Truncating this to 113 to add the ref app suffices
            WIN_REF_APP_IMAGE_TAG_PREFIX=$(echo "${LINUX_IMAGE_TAG}" | cut -c1-107)
            WIN_REF_APP_GOLANG_IMAGE_TAG=$WIN_REF_APP_IMAGE_TAG_PREFIX-win-ref-app-golang
            WIN_REF_APP_PYTHON_IMAGE_TAG=$WIN_REF_APP_IMAGE_TAG_PREFIX-win-ref-app-python
            # Truncating to 119 characters as it is required by docker (9 characters used in -ltsc2019/-ltsc2022)
            WINDOWS_2019_BASE_IMAGE_VERSION=ltsc2019
            WINDOWS_2022_BASE_IMAGE_VERSION=ltsc2022
            #Truncating this to 123 characters to add the conf prefix
            ARC_CONFORMANCE_TAG_SUFFIX=$(echo "${LINUX_IMAGE_TAG}" | cut -c1-123)
            ARC_CONFORMANCE_IMAGE_TAG=conf-$ARC_CONFORMANCE_TAG_SUFFIX
            LINUX_FULL_IMAGE_NAME=$ACR_REGISTRY$ACR_REPOSITORY:$LINUX_IMAGE_TAG
            TARGET_ALLOCATOR_FULL_IMAGE_NAME=$ACR_REGISTRY$ACR_REPOSITORY:$TARGET_ALLOCATOR_IMAGE_TAG
            LINUX_CONFIG_READER_FULL_IMAGE_NAME=$ACR_REGISTRY$ACR_REPOSITORY:$LINUX_CONFIG_READER_IMAGE_TAG
            LINUX_CCP_FULL_IMAGE_NAME=$ACR_REGISTRY$ACR_REPOSITORY:$LINUX_CCP_IMAGE_TAG
            WINDOWS_FULL_IMAGE_NAME=$ACR_REGISTRY$ACR_REPOSITORY:$WINDOWS_IMAGE_TAG
            HELM_FULL_IMAGE_NAME=$ACR_REGISTRY$ACR_REPOSITORY_HELM/$HELM_CHART_NAME:$SEMVER
            ARC_HELM_FULL_IMAGE_NAME=$ACR_REGISTRY$ACR_REPOSITORY_HELM/$ARC_HELM_CHART_NAME:$SEMVER
            LINUX_REF_APP_GOLANG_FULL_IMAGE_NAME=$ACR_REGISTRY$ACR_REPOSITORY:$LINUX_REF_APP_GOLANG_IMAGE_TAG
            LINUX_REF_APP_PYTHON_FULL_IMAGE_NAME=$ACR_REGISTRY$ACR_REPOSITORY:$LINUX_REF_APP_PYTHON_IMAGE_TAG
            WINDOWS_REF_APP_GOLANG_FULL_IMAGE_NAME=$ACR_REGISTRY$ACR_REPOSITORY:$WIN_REF_APP_GOLANG_IMAGE_TAG
            WINDOWS_REF_APP_PYTHON_FULL_IMAGE_NAME=$ACR_REGISTRY$ACR_REPOSITORY:$WIN_REF_APP_PYTHON_IMAGE_TAG
            ARC_CONFORMANCE_FULL_IMAGE_NAME=$ACR_REGISTRY$ACR_REPOSITORY:$ARC_CONFORMANCE_IMAGE_TAG
            LINUX_ARM64_FULL_IMAGE_NAME=$ACR_REGISTRY$ACR_REPOSITORY:$LINUX_ARM64_IMAGE_TAG
            LINUX_AMD64_FULL_IMAGE_NAME=$ACR_REGISTRY$ACR_REPOSITORY:$LINUX_AMD64_IMAGE_TAG
            TARGET_ALLOCATOR_ARM64_FULL_IMAGE_NAME=$ACR_REGISTRY$ACR_REPOSITORY:$TARGET_ALLOCATOR_ARM64_IMAGE_TAG
            TARGET_ALLOCATOR_AMD64_FULL_IMAGE_NAME=$ACR_REGISTRY$ACR_REPOSITORY:$TARGET_ALLOCATOR_AMD64_IMAGE_TAG
            echo "##vso[build.updatebuildnumber]$SEMVER"
            echo "##vso[task.setvariable variable=SEMVER;isOutput=true]$SEMVER"
            echo "##vso[task.setvariable variable=LINUX_FULL_IMAGE_NAME;isOutput=true]$LINUX_FULL_IMAGE_NAME"
            echo "##vso[task.setvariable variable=TARGET_ALLOCATOR_IMAGE_TAG;isOutput=true]$TARGET_ALLOCATOR_IMAGE_TAG"
            echo "##vso[task.setvariable variable=LINUX_CONFIG_READER_IMAGE_TAG;isOutput=true]$LINUX_CONFIG_READER_IMAGE_TAG"
            echo "##vso[task.setvariable variable=TARGET_ALLOCATOR_FULL_IMAGE_NAME;isOutput=true]$TARGET_ALLOCATOR_FULL_IMAGE_NAME"
            echo "##vso[task.setvariable variable=LINUX_CONFIG_READER_FULL_IMAGE_NAME;isOutput=true]$LINUX_CONFIG_READER_FULL_IMAGE_NAME"
            echo "##vso[task.setvariable variable=LINUX_CCP_FULL_IMAGE_NAME;isOutput=true]$LINUX_CCP_FULL_IMAGE_NAME"
            echo "##vso[task.setvariable variable=WINDOWS_FULL_IMAGE_NAME;isOutput=true]$WINDOWS_FULL_IMAGE_NAME"
            echo "##vso[task.setvariable variable=LINUX_REF_APP_GOLANG_FULL_IMAGE_NAME;isOutput=true]$LINUX_REF_APP_GOLANG_FULL_IMAGE_NAME"
            echo "##vso[task.setvariable variable=LINUX_REF_APP_PYTHON_FULL_IMAGE_NAME;isOutput=true]$LINUX_REF_APP_PYTHON_FULL_IMAGE_NAME"
            echo "##vso[task.setvariable variable=WINDOWS_REF_APP_GOLANG_FULL_IMAGE_NAME;isOutput=true]$WINDOWS_REF_APP_GOLANG_FULL_IMAGE_NAME"
            echo "##vso[task.setvariable variable=WINDOWS_REF_APP_PYTHON_FULL_IMAGE_NAME;isOutput=true]$WINDOWS_REF_APP_PYTHON_FULL_IMAGE_NAME"
            echo "##vso[task.setvariable variable=WINDOWS_IMAGE_TAG;isOutput=true]$WINDOWS_IMAGE_TAG"
            echo "##vso[task.setvariable variable=WINDOWS_2019_BASE_IMAGE_VERSION;isOutput=true]$WINDOWS_2019_BASE_IMAGE_VERSION"
            echo "##vso[task.setvariable variable=WINDOWS_2022_BASE_IMAGE_VERSION;isOutput=true]$WINDOWS_2022_BASE_IMAGE_VERSION"
            echo "##vso[task.setvariable variable=HELM_CHART_NAME;isOutput=true]$HELM_CHART_NAME"
            echo "##vso[task.setvariable variable=ARC_HELM_CHART_NAME;isOutput=true]$ARC_HELM_CHART_NAME"
            echo "##vso[task.setvariable variable=HELM_FULL_IMAGE_NAME;isOutput=true]$HELM_FULL_IMAGE_NAME"
            echo "##vso[task.setvariable variable=ARC_HELM_FULL_IMAGE_NAME;isOutput=true]$ARC_HELM_FULL_IMAGE_NAME"
            echo "##vso[task.setvariable variable=ARC_CONFORMANCE_FULL_IMAGE_NAME;isOutput=true]$ARC_CONFORMANCE_FULL_IMAGE_NAME"
            echo "##vso[task.setvariable variable=LINUX_ARM64_FULL_IMAGE_NAME;isOutput=true]$LINUX_ARM64_FULL_IMAGE_NAME"
            echo "##vso[task.setvariable variable=LINUX_AMD64_FULL_IMAGE_NAME;isOutput=true]$LINUX_AMD64_FULL_IMAGE_NAME"
            echo "##vso[task.setvariable variable=TARGET_ALLOCATOR_ARM64_IMAGE_TAG;isOutput=true]$TARGET_ALLOCATOR_ARM64_IMAGE_TAG"
            echo "##vso[task.setvariable variable=TARGET_ALLOCATOR_AMD64_IMAGE_TAG;isOutput=true]$TARGET_ALLOCATOR_AMD64_IMAGE_TAG"
            echo "##vso[task.setvariable variable=TARGET_ALLOCATOR_ARM64_FULL_IMAGE_NAME;isOutput=true]$TARGET_ALLOCATOR_ARM64_FULL_IMAGE_NAME"
            echo "##vso[task.setvariable variable=TARGET_ALLOCATOR_AMD64_FULL_IMAGE_NAME;isOutput=true]$TARGET_ALLOCATOR_AMD64_FULL_IMAGE_NAME"
          displayName: 'Build: set image registry, repo, and tags'
          name: setup
        - bash: |
            cd .pipelines/deployment/ServiceGroupRoot/Scripts
            cp ../../../../otelcollector/deploy/chart/prometheus-collector prometheus-collector -r
            cp ../../../../otelcollector/deploy/addon-chart/azure-monitor-metrics-addon ama-metrics-arc -r
            export MCR_REPOSITORY='/azuremonitor/containerinsights/ciprod/prometheus-collector/images'
            export MCR_REPOSITORY_HELM_DEPENDENCIES='/azuremonitor/containerinsights/ciprod'
            export HELM_SEMVER=$SETUP_SEMVER
            export IMAGE_TAG=$SETUP_SEMVER
            export IMAGE_TAG_WINDOWS=$SETUP_WINDOWS_IMAGE_TAG
            env
            envsubst < prometheus-collector/Chart-template.yaml > prometheus-collector/Chart.yaml && envsubst < prometheus-collector/values-template.yaml > prometheus-collector/values.yaml
            export ARC_EXTENSION=true
            export HELM_CHART_NAME=$ARC_HELM_CHART_NAME
            export ARC_RESOURCE_ID="/subscriptions/9b96ebbd-c57a-42d1-bbe9-b69296e4c7fb/resourceGroups/ci-prod-arc-wcus/providers/Microsoft.Kubernetes/connectedClusters/ci-prod-arc-wcus"
            export ARC_REGION="westcentralus"
            envsubst < ama-metrics-arc/Chart-template.yaml > ama-metrics-arc/Chart.yaml && envsubst < ama-metrics-arc/values-template.yaml > ama-metrics-arc/values.yaml
            tar -czvf ../artifacts.tar.gz pushAgentToAcr.sh pushChartToAcr.sh prometheus-collector ama-metrics-arc
            cd $(Build.ArtifactStagingDirectory)
            cp $(Build.SourcesDirectory)/otelcollector/deploy/addon-chart/azure-monitor-metrics-addon azure-monitor-metrics-addon -r
            export HELM_CHART_NAME="ama-metrics"
            export ARC_EXTENSION=false
            export AKS_REGION="westeurope"
            export AKS_RESOURCE_ID="/subscriptions/9b96ebbd-c57a-42d1-bbe9-b69296e4c7fb/resourceGroups/ci-prod-aks-mac-weu-rg/providers/Microsoft.ContainerService/managedClusters/ci-prod-aks-mac-weu"
            envsubst < azure-monitor-metrics-addon/Chart-template.yaml > azure-monitor-metrics-addon/Chart.yaml && envsubst < azure-monitor-metrics-addon/values-template.yaml > azure-monitor-metrics-addon/values.yaml

            echo $(Build.BuildNumber) > "$(Build.SourcesDirectory)/.pipelines/deployment/ServiceGroupRoot/buildver.txt"
            echo $(Build.BuildNumber) > "$(Build.SourcesDirectory)/.pipelines/deployment/arc-extension-release/ServiceGroupRoot/buildver.txt"
          displayName: 'Ev2: package artifacts.tar.gz for prod release'
        - task: HelmInstaller@1
          displayName: 'CI/CD: Install Helm version for linting'
          condition: or(eq(variables.IS_PR, true), eq(variables.IS_MAIN_BRANCH, true))
          inputs:
            helmVersionToInstall: $(HELM_VERSION)
        - bash: |
            # Lint ama-metrics-arc chart (ARC extension)
            cd $(Build.SourcesDirectory)/.pipelines/deployment/ServiceGroupRoot/Scripts/ama-metrics-arc
            helm lint .
            if [ $? -ne 0 ]; then
              echo "Error: Helm lint failed for ama-metrics-arc chart"
              exit 1
            fi
            
            # Lint ama-metrics chart (AKS addon)
            cd $(Build.ArtifactStagingDirectory)/azure-monitor-metrics-addon
            helm lint .
            if [ $? -ne 0 ]; then
              echo "Error: Helm lint failed for ama-metrics chart"
              exit 1
            fi
            
            echo "All Helm charts passed linting!"
          displayName: "CI/CD: Lint Helm charts"
          condition: or(eq(variables.IS_PR, true), eq(variables.IS_MAIN_BRANCH, true))
        - bash: |
            cd $(Build.SourcesDirectory)/.pipelines/deployment/arc-extension-release/ServiceGroupRoot/Scripts
            tar -czvf ../extension-artifacts.tar.gz arcExtensionRelease.sh
          displayName: 'Ev2: package extension-artifacts.tar.gz for prod release'
        - task: CredScan@3
          displayName: "SDL : Run credscan"
        - task: CopyFiles@2
          displayName: "Ev2: copy Ev2 deployment artifacts to staging directory"
          inputs:
            SourceFolder: "$(Build.SourcesDirectory)/.pipelines/deployment"
            Contents: |
              **/*
            TargetFolder: '$(Build.ArtifactStagingDirectory)/deploy'
      - job: Windows_Python_Reference_App
        displayName: "Build: windows python reference app image"
        pool:
          name: Azure-Pipelines-CI-Test-EO
          image: ci-1es-managed-windows-2022
          os: windows
        dependsOn: Image_Tags_and_Ev2_Artifacts
        variables:
          WINDOWS_REF_APP_PYTHON_FULL_IMAGE_NAME: $[ dependencies.Image_Tags_and_Ev2_Artifacts.outputs['setup.WINDOWS_REF_APP_PYTHON_FULL_IMAGE_NAME'] ]
          skipComponentGovernanceDetection: true
        condition: succeeded()
        steps:
        - powershell: |
            New-Item -Path "$(Build.ArtifactStagingDirectory)" -Name "refapppythonwindows" -ItemType "directory"
            docker build . --isolation=hyperv --file windows/Dockerfile -t $(WINDOWS_REF_APP_PYTHON_FULL_IMAGE_NAME)
            docker login containerinsightsprod.azurecr.io -u $(ACR_USERNAME) -p $(ACR_PASSWORD)
            docker push $(WINDOWS_REF_APP_PYTHON_FULL_IMAGE_NAME)
            docker pull $(WINDOWS_REF_APP_PYTHON_FULL_IMAGE_NAME)
          displayName: "Build: build and push reference app python windows image to dev ACR"
          workingDirectory: $(Build.SourcesDirectory)/internal/referenceapp/python
        - powershell: |
            $output = docker manifest inspect -v $(WINDOWS_REF_APP_PYTHON_FULL_IMAGE_NAME) | ConvertFrom-Json
            $firstManifest = $output[0]
            $MEDIA_TYPE = $firstManifest.Descriptor.mediaType
            $DIGEST = $firstManifest.Descriptor.digest
            $SIZE = $firstManifest.Descriptor.size
            $payload = @{
                targetArtifact = @{
                    mediaType = $MEDIA_TYPE
                    digest = $DIGEST
                    size = $SIZE
                }
            } | ConvertTo-Json
            $payload | Out-File -FilePath "$(Build.ArtifactStagingDirectory)/refapppythonwindows/payload.json"
          workingDirectory: $(Build.SourcesDirectory)/internal/referenceapp/python
          displayName: "Build the payload json file"
          condition: succeeded()
        - task: EsrpCodeSigning@5
          displayName: "ESRP CodeSigning for Prometheus Python Windows Reference App"
          inputs:
            ConnectedServiceName: "ESRPServiceConnectionPrometheus"
            UseMSIAuthentication: true
            AppRegistrationClientId: 'bf21d5fe-78bd-45d2-b04d-c61f2e090c9a'
            AppRegistrationTenantId: '33e01921-4d64-4f8c-a055-5bdaffd5e33d'
            EsrpClientId: "73f8d5f9-b507-497f-b698-4ed00fcba5a3"
            AuthAKVName: 'ESRPPrometheusKVProd'
            AuthCertName: 'ESRPContainerImageSignCert'
            AuthSignCertName: 'ESRPReqPrometheusProdCert'
            FolderPath: $(Build.ArtifactStagingDirectory)/refapppythonwindows/
            Pattern: "*.json"
            signConfigType: inlineSignParams
            inlineOperation: |
              [
                {
                    "keyCode": "CP-469451",
                    "operationSetCode": "NotaryCoseSign",
                    "parameters": [
                      {
                        "parameterName": "CoseFlags",
                        "parameterValue": "chainunprotected"
                      }
                    ],
                    "toolName": "sign",
                    "toolVersion": "1.0"
                }
              ]
            SessionTimeout: '60'
            MaxConcurrency: '50'
            MaxRetryAttempts: '5'
            PendingAnalysisWaitTimeoutMinutes: '5'
        - powershell: |
            curl.exe -sLO  "https://github.com/oras-project/oras/releases/download/v1.0.0/oras_1.0.0_windows_amd64.zip"
            $currentDirectory = Get-Location
            Expand-Archive -Path $currentDirectory\oras_1.0.0_windows_amd64.zip -DestinationPath . -Force
            New-Item -ItemType Directory -Force -Path $env:USERPROFILE\bin
            Copy-Item -Path $currentDirectory\oras.exe -Destination "$env:USERPROFILE\bin\"
            $env:PATH = "$env:USERPROFILE\bin;$env:PATH"
            oras attach $(WINDOWS_REF_APP_PYTHON_FULL_IMAGE_NAME) --artifact-type application/vnd.cncf.notary.signature ./payload.json:application/cose -a io.cncf.notary.x509chain.thumbprint#S256=[\""79E6A702361E1F60DAA84AEEC4CBF6F6420DE6BA\""]
            oras attach $(WINDOWS_REF_APP_PYTHON_FULL_IMAGE_NAME) --artifact-type 'application/vnd.microsoft.artifact.lifecycle' --annotation "vnd.microsoft.artifact.lifecycle.end-of-life.date=$(powershell -Command "(Get-Date).AddHours(-1).ToString('yyyy-MM-ddTHH:mm:ssZ')")"          
          workingDirectory: $(Build.ArtifactStagingDirectory)/refapppythonwindows/
          displayName: "Download, install Oras and run oras attach"
          condition: succeeded()